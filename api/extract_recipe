from http.server import BaseHTTPRequestHandler
from urllib.parse import urlparse, parse_qs
import json
import sys
import os
import logging
from recipe_scrapers import scrape_me
import time

# Set up logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

def extract_recipe_full(url):
    """
    Extracts core recipe data using recipe_scrapers.
    This is the single source of truth for all recipe processing.
    """
    try:
        logger.debug(f"Attempting to scrape recipe from URL: {url}")
        scraper = scrape_me(url)
        logger.debug("Successfully created scraper instance.")

        # Extract recipe data matching the specified schema
        recipe_data = {
            "title": getattr(scraper, 'title', lambda: 'No Title')(),
            "image": getattr(scraper, 'image', lambda: None)(),
            "totalTime": getattr(scraper, 'total_time', lambda: 0)(),
            "yields": getattr(scraper, 'yields', lambda: 'N/A')(),
            "sourceUrl": url,
            "ingredients": getattr(scraper, 'ingredients', lambda: [])(),
            "instructions": getattr(scraper, 'instructions_list', lambda: [])(),
        }

        logger.debug("Successfully extracted recipe data.")
        
        return {"success": True, "data": recipe_data}

    except Exception as e:
        logger.error(f"Error extracting recipe from {url}: {str(e)}", exc_info=True)
        return {"success": False, "error": str(e)}

# Handle both serverless function and command line usage
if __name__ == "__main__":
    logger.debug("Running in command line mode")
    if len(sys.argv) > 1:
        url = sys.argv[1]
        logger.debug(f"Received URL argument: {url}")
        result = extract_recipe_full(url)
        print(json.dumps(result))
        sys.exit(0 if result["success"] else 1)
    else:
        logger.error("No URL provided in command line arguments")
        sys.exit(1)
else:
    logger.debug("Running in serverless function mode")
    # This 'handler' class is for deployment environments like Vercel's Python runtime
    class handler(BaseHTTPRequestHandler):
        def do_GET(self):
            # --- Stage: Request Received ---
            start_time = time.time()
            logger.info("Stage: Request Received - Start")
            query = parse_qs(urlparse(self.path).query)
            url = query.get('url', [None])[0]

            if not url:
                self.send_response(400)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(json.dumps({"success": False, "error": "Missing 'url' query parameter"}).encode('utf-8'))
                logger.warning("Stage: Request Received - End: Responded with 400 due to missing URL.")
                return
            
            request_duration = time.time() - start_time
            logger.info(f"Stage: Request Received - End, Duration: {request_duration:.2f}s")

            # --- Call the extraction function ---
            result = extract_recipe_full(url)

            # --- Stage: Response Assembly ---
            assembly_start_time = time.time()
            logger.info("Stage: Response Assembly - Start")
            if result["success"]:
                response_payload = json.dumps(result["data"], indent=2)
                logger.info(f"Stage: Response Assembly - Final Output (200 OK):\n{response_payload}")
                self.send_response(200)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_payload.encode('utf-8'))
            else:
                response_payload = json.dumps(result, indent=2)
                logger.error(f"Stage: Response Assembly - Final Output (500 Error):\n{response_payload}")
                self.send_response(500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                self.wfile.write(response_payload.encode('utf-8'))
            
            assembly_duration = time.time() - assembly_start_time
            logger.info(f"Stage: Response Assembly - End - Duration: {assembly_duration:.2f}s")

    sys.modules['__main__'].handler = handler # type: ignore